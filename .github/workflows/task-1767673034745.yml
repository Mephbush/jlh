name: Web Automation Bot

on:
  workflow_dispatch:
    inputs:
      runCount:
        description: 'Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ù‡Ù…Ø©'
        required: false
        default: '1'
        type: string
      taskId:
        description: 'Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ù‡Ù…Ø©'
        required: false
        type: string
      taskName:
        description: 'Ø§Ø³Ù… Ø§Ù„Ù…Ù‡Ù…Ø©'
        required: false
        type: string
  schedule:
    - cron: '0 */6 * * *'

jobs:
  automation:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install Dependencies
        run: |
          npm install playwright
          npx playwright install chromium
      
      - name: Create Results Directory
        run: mkdir -p results
      
      - name: Run Task Multiple Times
        run: |
          cat > run_task.js << 'EOF'
          const { chromium } = require('playwright');
          const fs = require('fs');
          const path = require('path');
          
          const STEALTH_CONFIG = {
            blockWebRTC: true,
            randomUserAgent: true,
            randomViewport: true,
            hideWebdriver: true,
            level: 'advanced'
          };
          
          const TASK_DATA = {
            name: 'Ø¬Ù†Ø§Ù† Ø§Ù„ØªØºÙ„ÙŠÙ‚',
            type: 'custom',
            targetUrl: 'https://rescend.netlify.app/',
            script: 'import { chromium } from \'playwright\';
import fs from \'fs/promises\';
import path from \'path\';
import { fileURLToPath } from \'url\';
import { dirname } from \'path\';
import { createStealthBrowser, humanClick, humanType, humanScroll } from \'./stealth-helpers.js\';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ø©
const TASK = {
  "id": "1767673034745",
  "name": "Ø¬Ù†Ø§Ù† Ø§Ù„ØªØºÙ„ÙŠÙ‚",
  "description": "Ù…Ù‡Ù…Ø© ØªÙ… Ø¥Ù†Ø´Ø§Ø¤Ù‡Ø§ Ø¨Ø§Ù„Ù…Ù†Ø´Ø¦ Ø§Ù„Ù…Ø±Ø¦ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…",
  "type": "custom",
  "status": "idle",
  "script": "const { chromium } = require(\'playwrigh\n\n// ============================================\n// ØªØ·Ø¨ÙŠÙ‚ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ®ÙÙŠ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ\n// ============================================\n\n\n// 1. Ø¥Ø®ÙØ§Ø¡ Ø¹Ù„Ø§Ù…Ø§Øª Webdriver\ntry {\n  Object.defineProperty(navigator, \'webdriver\', { get: () => undefined });\n  delete navigator.__proto__.webdriver;\n} catch (e) {}\n\n// 2. Ø¥Ø®ÙØ§Ø¡ Ø¨ØµÙ…Ø© Ø§Ù„Ù…ØªØµÙØ­ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…\ntry {\n  Object.defineProperty(HTMLCanvasElement.prototype, \'toDataURL\', {\n    value: function() {\n      return \'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwADhgGAWjR9awAAAABJRU5ErkJggg==\';\n    }\n  });\n} catch (e) {}\n\n// 3. ØªØ¹ÙŠÙŠÙ† Ù…Ù†Ø·Ù‚Ø© Ø²Ù…Ù†ÙŠØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©\ntry {\n  const timezones = [\'UTC\', \'GMT\', \'EST\', \'CST\', \'MST\', \'PST\', \'GMT+1\', \'GMT+2\'];\n  const tz = timezones[Math.floor(Math.random() * timezones.length)];\n  process.env.TZ = tz;\n} catch (e) {}\n\n// 4. Ø­Ø¸Ø± WebRTC (Ù…Ù†Ø¹ ØªØ³Ø±ÙŠØ¨ IP Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ)\ntry {\n  window.RTCPeerConnection = undefined;\n  window.webkitRTCPeerConnection = undefined;\n} catch (e) {}\n\n// 5. Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ±Ø§Øª Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©\nconst baseWait = async (ms) => new Promise(r => setTimeout(r, ms));\nconst randomWait = async (min = 100, max = 500) => {\n  const delay = min + Math.random() * (max - min);\n  return new Promise(r => setTimeout(r, delay));\n};\n\n// 6. Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø© (ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©)\ntry {\n  if (typeof localStorage !== \'undefined\') localStorage.clear();\n  if (typeof sessionStorage !== \'undefined\') sessionStorage.clear();\n} catch (e) {}\n\n// 7. Ù…Ø­Ø§ÙƒØ§Ø© Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù…Ø§ÙˆØ³ Ø§Ù„Ø¨Ø´Ø±ÙŠØ©\nconst sleep = (ms) => new Promise(r => setTimeout(r, ms));\nconst humanDelay = () => new Promise(r => setTimeout(r, 50 + Math.random() * 150));\n\n// ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†Ø¬Ø§Ø­\nconsole.log(\'âœ… ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ®ÙÙŠ Ø¨Ù†Ø¬Ø§Ø­\');\n\nt\');\n\nasync function runTask(page, context) {\n  // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙˆÙ…ØªØºÙŠØ±Ø§Øª Ø§Ù„ØªØªØ¨Ø¹\n  let currentPage = page;\n  const pages = {};\n  pages[\'main\'] = page;\n  \n  try {\n    // Step 1: ØªØ³Ø¬ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆ\n    let retries_step1 = 3;\n    while (retries_step1 > 0) {\n      try {\n        // ğŸ¥ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ - ØªÙ… ØªÙØ¹ÙŠÙ„Ù‡ Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø³ÙŠØ§Ù‚\n        console.log(\'ğŸ¥ Ø®Ø·ÙˆØ© Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù†Ø´Ø·\');\n        console.log(\'   â„¹ï¸  Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙŠØ´Ù…Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙØ­Ø§Øª ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø³ÙŠØ§Ù‚\');\n        console.log(\'   ğŸ“ Ø­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: videos/\');\n        console.log(\'   âœ… Ø³ÙŠØªÙ… Ø­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ù†Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø³ÙŠØ§Ù‚ (Ù†Ø¬Ø§Ø­ Ø£Ùˆ ÙØ´Ù„)\');\n                break;\n      } catch (stepError) {\n        retries_step1--;\n        if (retries_step1 === 0) {\n          throw stepError;\n        }\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n\n    // Step 2: ÙØªØ­ ØµÙØ­Ø©\n    let retries_step2 = 3;\n    while (retries_step2 > 0) {\n      try {\n        // ğŸŒ ÙØªØ­ ØµÙØ­Ø© Ø¬Ø¯ÙŠØ¯Ø©: https://rescend.netlify.app/\n        const resc = await context.newPage();\n        await resc.goto(\"https://rescend.netlify.app/\");\n        pages[\"resc\"] = resc;\n        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„Ø¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©\n        currentPage = resc;\n        console.log(\'ğŸŒ ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ ØµÙØ­Ø© Ø¬Ø¯ÙŠØ¯Ø©: https://rescend.netlify.app/\');\n                break;\n      } catch (stepError) {\n        retries_step2--;\n        if (retries_step2 === 0) {\n          throw stepError;\n        }\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n\n    // Step 3: Ø§Ù†ØªØ¸Ø§Ø±\n    let retries_step3 = 3;\n    while (retries_step3 > 0) {\n      try {\n        await currentPage.waitForTimeout(5000);\n                break;\n      } catch (stepError) {\n        retries_step3--;\n        if (retries_step3 === 0) {\n          throw stepError;\n        }\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n\n    // Step 4: ØªÙ…Ø±ÙŠØ± Ø§Ù„ØµÙØ­Ø©\n    let retries_step4 = 3;\n    while (retries_step4 > 0) {\n      try {\n        // ğŸ“œ ØªÙ…Ø±ÙŠØ± Ø·Ø¨ÙŠØ¹ÙŠ ÙˆØ¨Ø´Ø±ÙŠ\n        const scrollTarget = await currentPage.evaluate(() => document.body.scrollHeight - window.innerHeight);\n        \n        // ØªÙ…Ø±ÙŠØ± Ø·Ø¨ÙŠØ¹ÙŠ Ø¨Ø­Ø±ÙƒØ© Ø§Ù„Ø¥ØµØ¨Ø¹ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø©\n        await page.evaluate(async ({ from, to, fingerTouches, randomVariation }) => {\n          return new Promise((resolve) => {\n            const distance = to - from;\n            const direction = distance > 0 ? 1 : -1;\n            let currentPos = from;\n            let touchIndex = 0;\n            let velocity = 0;\n        \n            const simulateFingerGesture = async () => {\n              // Ø­Ø±ÙƒØ© Ø§Ù„Ø¥ØµØ¨Ø¹ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø© Ù…Ø¹ ØªØ¨Ø§ÙŠÙ† Ø¹Ø´ÙˆØ§Ø¦ÙŠ\n              const touchStepSize = Math.abs(distance) / fingerTouches;\n              const touchDuration = 900 / fingerTouches;\n              const baseDelay = touchDuration / 4;\n        \n              while ((direction > 0 ? currentPos < to : currentPos > to)) {\n                touchIndex++;\n                const nextPos = Math.min(Math.max(currentPos + (touchStepSize * direction), from), to);\n                const variation = 1 + ((Math.random() - 0.5) * randomVariation / 100);\n                const stepDuration = touchDuration * variation;\n        \n                // Ù…Ø­Ø§ÙƒØ§Ø© Ø­Ø±ÙƒØ© Ø§Ù„Ø¥ØµØ¨Ø¹ Ù…Ø¹ ØªØ³Ø§Ø±Ø¹ Ø·Ø¨ÙŠØ¹ÙŠ\n                await new Promise(resolve => {\n                  const startTime = performance.now();\n                  const startPos = currentPos;\n        \n                  const animateFinger = (currentTime) => {\n                    const elapsed = currentTime - startTime;\n                    const progress = Math.min(elapsed / stepDuration, 1);\n        \n                    // ØªØ³Ø§Ø±Ø¹ Ø·Ø¨ÙŠØ¹ÙŠ Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¥ØµØ¨Ø¹\n                    const easeProgress = progress < 0.5\n                      ? 2 * progress * progress\n                      : -1 + (4 - 2 * progress) * progress;\n        \n                    currentPos = startPos + (nextPos - startPos) * easeProgress;\n                    window.scrollTo(0, currentPos);\n        \n                    if (progress < 1) {\n                      requestAnimationFrame(animateFinger);\n                    } else {\n                      window.scrollTo(0, nextPos);\n                      velocity = (nextPos - startPos) / stepDuration;\n                      resolve();\n                    }\n                  };\n        \n                  requestAnimationFrame(animateFinger);\n                });\n        \n                // ØªÙˆÙ‚Ù Ø¹Ø´ÙˆØ§Ø¦ÙŠ ØµØºÙŠØ± Ø¨ÙŠÙ† Ø§Ù„Ø­Ø±ÙƒØ§Øª (Ù…Ø­Ø§ÙƒØ§Ø© Ø­Ø±ÙƒØ© Ø§Ù„Ø¥ØµØ¨Ø¹ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ©)\n                await new Promise(r => setTimeout(r, baseDelay * (0.5 + Math.random())));\n              }\n        \n              // ØªÙˆÙ‚Ù Ù†Ù‡Ø§Ø¦ÙŠ\n              window.scrollTo(0, to);\n              resolve();\n            };\n        \n            simulateFingerGesture();\n          });\n        }, {\n          from: 0,\n          to: 999999,\n          fingerTouches: 6,\n          randomVariation: 20\n        });\n                break;\n      } catch (stepError) {\n        retries_step4--;\n        if (retries_step4 === 0) {\n          throw stepError;\n        }\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n\n    // Step 5: Ø§Ù†ØªØ¸Ø§Ø±\n    let retries_step5 = 3;\n    while (retries_step5 > 0) {\n      try {\n        await currentPage.waitForTimeout(8950);\n                break;\n      } catch (stepError) {\n        retries_step5--;\n        if (retries_step5 === 0) {\n          throw stepError;\n        }\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n\n    // Step 6: Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø¹Ù†ØµØ±\n    let retries_step6 = 3;\n    while (retries_step6 > 0) {\n      try {\n        \n        // ğŸ‘† Ø®Ø·ÙˆØ© Ù†Ù‚Ø± Ø°ÙƒÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ±\n        console.log(\'ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¹Ù†ØµØ± Ø¨Ù€ 1 Ù…Ø­Ø¯Ø¯(Ø§Øª)...\');\n        \n        // ğŸ”— Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø·ÙˆØ© ØªØ³ØªÙ‡Ø¯Ù Ø¹Ù†ØµØ±Ø§Ù‹ Ø¯Ø§Ø®Ù„ iframe (Ù…Ø¹ Ø¯Ø¹Ù… cross-origin CORS)\n        // âš ï¸ ØªØ­Ø°ÙŠØ±: Ù‡Ø°Ø§ iframe Ù…Ù† Ø¯ÙˆÙ…ÙŠÙ† Ø®Ø§Ø±Ø¬ÙŠ (Cross-Origin)\n        // ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ --disable-web-security Ø¹Ù†Ø¯ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ØªØµÙØ­\n        \n        // Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø­Ø¯Ø¯Ø§Øª iframe Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©\n        let iframeElement = null;\n        const iframeSelectorsToTry = [\"iframe.â–¶__iframe\"];\n        \n        for (const ifSel of iframeSelectorsToTry) {\n          try {\n            iframeElement = await page.locator(ifSel).first();\n            const exists = await iframeElement.count().catch(() => 0) > 0;\n            if (exists) {\n              console.log(\'âœ… ÙˆØ¬Ø¯Ù†Ø§ iframe Ø¨Ù€ selector:\', ifSel);\n              break;\n            }\n          } catch (e) {\n            console.log(\'âš ï¸ ÙØ´Ù„ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† iframe Ø¨Ù€:\', ifSel);\n          }\n        }\n        \n        if (!iframeElement) throw new Error(\'âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ iframe\');\n        // ============================================\n        // Ù…Ø¹Ø§Ù„Ø¬ Ù…ØªÙ‚Ø¯Ù… Ù„Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø¹Ù†Ø§ØµØ± Ø¯Ø§Ø®Ù„ iframe Ù…Ø­Ù…ÙŠØ© CORS\n        // Advanced handler for clicking elements inside cross-origin iframes\n        // ============================================\n        \n        async function clickElementInCrossOriginIFrame(page) {\n          const iframeSelector = \"iframe.â–¶__iframe\";\n          const elementSelectors = [\"a[href*=\'cultivated-cell.com\']\"];\n          const config = {\n            timeout: 5000,\n            maxRetries: 3,\n            handleHiddenElements: true\n          };\n        \n          console.log(\'ğŸ” Ù…Ø¹Ø§Ù„Ø¬ Ù…ØªÙ‚Ø¯Ù… Ù„Ù„Ù€ iframe Ù…Ø­Ù…ÙŠØ© CORS\');\n        \n          let iframeElement = null;\n          let frameHandle = null;\n          let isCrossOrigin = false;\n        \n          // Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† iframe ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†ÙˆØ¹Ù‡\n          console.log(\'ğŸ” Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† iframe ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£ØµÙ„Ù‡...\');\n        \n          try {\n            const iframe = await page.locator(iframeSelector).first();\n            const exists = await iframe.count().catch(() => 0) > 0;\n        \n            if (!exists) {\n              throw new Error(\'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ iframe: \' + iframeSelector);\n            }\n        \n            iframeElement = iframe;\n            console.log(\'âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ iframe\');\n        \n            // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ÙƒØ´Ù Ø¹Ù† Ù†ÙˆØ¹ iframe (same-origin Ø£Ùˆ cross-origin)\n            console.log(\'ğŸ” ÙØ­Øµ Ù†ÙˆØ¹ iframe...\');\n        \n            // Ù…Ø­Ø§ÙˆÙ„Ø© contentFrame() Ø£ÙˆÙ„Ø§Ù‹ (Ù„Ù„Ù€ same-origin)\n            try {\n              frameHandle = await iframeElement.contentFrame();\n              if (frameHandle) {\n                isCrossOrigin = false;\n                console.log(\'âœ… iframe Ù…Ù† Ù†ÙØ³ Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ† (same-origin) - Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… contentFrame()\');\n              }\n            } catch (e) {\n              // contentFrame() ÙØ´Ù„ - ÙŠØ¹Ù†ÙŠ Ù‡Ø°Ø§ cross-origin iframe\n              isCrossOrigin = true;\n              console.log(\'âš ï¸ ØªÙ… Ø§ÙƒØªØ´Ø§Ù iframe Ù…Ù† Ø¯ÙˆÙ…ÙŠÙ† Ø®Ø§Ø±Ø¬ÙŠ (Cross-Origin)\');\n              console.log(\'   Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… frameLocator() Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† contentFrame()\');\n            }\n          } catch (e) {\n            throw new Error(\'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† iframe: \' + e.message);\n          }\n        \n          // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª cross-originØŒ Ø§Ø³ØªØ®Ø¯Ù… frameLocator() Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† contentFrame()\n          if (isCrossOrigin) {\n            console.log(\'\\nğŸ”— Ù…Ø¹Ø§Ù„Ø¬Ø© Cross-Origin iframe Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… frameLocator()...\');\n        \n            // Ø§Ø³ØªØ®Ø¯Ø§Ù… frameLocator() Ø§Ù„Ø°ÙŠ ÙŠØ¹Ù…Ù„ Ù…Ø¹ Cross-Origin iframes\n            console.log(\'ğŸ“ Ø§Ø³ØªØ®Ø¯Ø§Ù… frameLocator() Ù„Ù„Ø¨Ø­Ø« Ø¯Ø§Ø®Ù„ iframe Ù…Ù† Ø¯ÙˆÙ…ÙŠÙ† Ø®Ø§Ø±Ø¬ÙŠ...\');\n        \n            let clickSuccess = false;\n            let lastError = null;\n        \n            for (const elementSelector of elementSelectors) {\n              try {\n                console.log(\'   Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯: \' + elementSelector);\n        \n                // Ø§Ø³ØªØ®Ø¯Ø§Ù… frameLocator Ù…Ø¹ elementSelector\n                const frameLocatorElement = page.frameLocator(iframeSelector).locator(elementSelector).first();\n                const exists = await frameLocatorElement.count().catch(() => 0) > 0;\n        \n                if (!exists) {\n                  console.log(\'   âš ï¸ Ø§Ù„Ù…Ø­Ø¯Ø¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯: \' + elementSelector);\n                  continue;\n                }\n        \n                console.log(\'   âœ… ÙˆØ¬Ø¯Ù†Ø§ Ø§Ù„Ø¹Ù†ØµØ± Ø¯Ø§Ø®Ù„ iframe\');\n        \n                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±Ø¤ÙŠØ© ÙˆØ§Ù„Ù†Ù‚Ø±\n                if (config.handleHiddenElements) {\n                  try {\n                    const isVisible = await frameLocatorElement.isVisible({ timeout: 1000 }).catch(() => false);\n        \n                    if (!isVisible) {\n                      console.log(\'   ğŸ”“ Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø®ÙÙŠ...\');\n        \n                      await page.frameLocator(iframeSelector).evaluate((sel) => {\n                        const el = document.querySelector(sel);\n                        if (el) {\n                          el.style.display = \'\';\n                          el.style.visibility = \'\';\n                          el.style.opacity = \'1\';\n                          el.style.zIndex = \'99999\';\n                          el.removeAttribute(\'hidden\');\n                        }\n                      }, elementSelector);\n        \n                      console.log(\'   âœ… ØªÙ… Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¹Ù†ØµØ±\');\n                    }\n                  } catch (e) {\n                    console.log(\'   âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¹Ù†ØµØ±: \' + e.message);\n                  }\n                }\n        \n                // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ø¹Ù†ØµØ± Ø¥Ù„Ù‰ Ø¹Ø±Ø¶ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§\n                try {\n                  await frameLocatorElement.scrollIntoViewIfNeeded();\n                  console.log(\'   ğŸ“œ ØªÙ… Ø§Ù„ØªÙ…Ø±ÙŠØ± Ø¥Ù„Ù‰ Ø¹Ø±Ø¶ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§\');\n                } catch (e) {\n                  console.log(\'   âš ï¸ ÙØ´Ù„ Ø§Ù„ØªÙ…Ø±ÙŠØ±: \' + e.message);\n                }\n        \n                // ØªÙ†ÙÙŠØ° Ø§Ù„Ù†Ù‚Ø±Ø©\n                console.log(\'   ğŸ–±ï¸ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ±...\');\n                try {\n                  await frameLocatorElement.click({ timeout: 5000 });\n                  console.log(\'   âœ… ØªÙ… Ø§Ù„Ù†Ù‚Ø± Ø¨Ù†Ø¬Ø§Ø­\');\n                  clickSuccess = true;\n                  break;\n                } catch (clickError) {\n                  console.log(\'   âš ï¸ ÙØ´Ù„ Ø§Ù„Ù†Ù‚Ø± Ø§Ù„Ø¹Ø§Ø¯ÙŠØŒ Ø¬Ø§Ø±ÙŠ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ù†Ù‚Ø± Ø§Ù„Ø¬Ø¨Ø±ÙŠ...\');\n                  try {\n                    await frameLocatorElement.click({ force: true });\n                    console.log(\'   âœ… ØªÙ… Ø§Ù„Ù†Ù‚Ø± Ø§Ù„Ø¬Ø¨Ø±ÙŠ Ø¨Ù†Ø¬Ø§Ø­\');\n                    clickSuccess = true;\n                    break;\n                  } catch (forceClickError) {\n                    lastError = forceClickError;\n                    console.log(\'   âŒ ÙØ´Ù„ Ø§Ù„Ù†Ù‚Ø± Ø§Ù„Ø¬Ø¨Ø±ÙŠ: \' + forceClickError.message);\n                  }\n                }\n              } catch (e) {\n                lastError = e;\n                console.log(\'   âŒ Ø®Ø·Ø£: \' + e.message);\n                continue;\n              }\n            }\n        \n            if (!clickSuccess) {\n              throw new Error(\n                \'ÙØ´Ù„ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ± Ø¯Ø§Ø®Ù„ Cross-Origin iframe. \\n\' +\n                \'Ø§Ù„Ø³Ø¨Ø¨ Ø§Ù„Ù…Ø­ØªÙ…Ù„: \' + (lastError?.message || \'Ø§Ù„Ø¹Ù†ØµØ± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ ØºÙŠØ± Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªÙØ§Ø¹Ù„\') + \'\\n\' +\n                \'ØªØ£ÙƒØ¯ Ù…Ù†: 1) Ø§Ù„Ù…Ø­Ø¯Ø¯ ØµØ­ÙŠØ­ 2) Ø§Ù„Ù…ØªØµÙØ­ ÙŠØ¹Ù…Ù„ Ø¨Ù€ --disable-web-security 3) Ø§Ù„Ø¹Ù†ØµØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ iframe\'\n              );\n            }\n        \n            return; // Ù†Ù‡Ø§ÙŠØ© Ù…Ø¹Ø§Ù„Ø¬Ø© cross-origin\n          }\n        \n          // Ø¥Ø°Ø§ Ù†Ø¬Ø­Ù†Ø§ ÙÙŠ Ø§Ù„Ø¯Ø®ÙˆÙ„ (same-origin)\n          console.log(\'\\nğŸ” Ø§Ù„Ø®Ø·ÙˆØ© 2: Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¹Ù†ØµØ± Ø¯Ø§Ø®Ù„ iframe...\');\n        \n          let clickSuccess = false;\n          let lastError = null;\n        \n          for (const elementSelector of elementSelectors) {\n            try {\n              console.log(\'   Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯: \' + elementSelector);\n        \n              const element = await frameHandle.locator(elementSelector).first();\n              const exists = await element.count().catch(() => 0) > 0;\n        \n              if (!exists) {\n                console.log(\'   âš ï¸ Ø§Ù„Ù…Ø­Ø¯Ø¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯: \' + elementSelector);\n                continue;\n              }\n        \n              console.log(\'   âœ… ÙˆØ¬Ø¯Ù†Ø§ Ø§Ù„Ø¹Ù†ØµØ±\');\n        \n              // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¹Ù†ØµØ± Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±\n              if (config.handleHiddenElements) {\n                try {\n                  const isVisible = await element.isVisible({ timeout: 1000 }).catch(() => false);\n        \n                  if (!isVisible) {\n                    console.log(\'   ğŸ”“ Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø®ÙÙŠ...\');\n        \n                    await frameHandle.evaluate((sel) => {\n                      const el = document.querySelector(sel);\n                      if (el) {\n                        el.style.display = \'\';\n                        el.style.visibility = \'\';\n                        el.style.opacity = \'1\';\n                        el.style.zIndex = \'99999\';\n                        el.removeAttribute(\'hidden\');\n                      }\n                    }, elementSelector);\n        \n                    await element.scrollIntoViewIfNeeded().catch(() => {});\n                    await frameHandle.waitForTimeout(300);\n                  }\n                } catch (e) {\n                  console.log(\'   âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¹Ù†ØµØ±: \' + e.message);\n                }\n              }\n        \n              // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ù†Ù‚Ø±\n              for (let retry = 0; retry < config.maxRetries; retry++) {\n                try {\n                  console.log(\'      Ù…Ø­Ø§ÙˆÙ„Ø© Ù†Ù‚Ø± \' + (retry + 1) + \'/\' + config.maxRetries);\n        \n                  if (retry === 0) {\n                    await element.click({ timeout: 1000 }).catch(() => {});\n                  } else if (retry === 1) {\n                    await element.click({ force: true, timeout: 1000 });\n                  } else {\n                    await frameHandle.evaluate((sel) => {\n                      const el = document.querySelector(sel);\n                      if (el) el.click();\n                    }, elementSelector);\n                  }\n        \n                  console.log(\'      âœ… Ù†Ù‚Ø± Ù†Ø§Ø¬Ø­!\');\n                  clickSuccess = true;\n                  break;\n                } catch (e) {\n                  lastError = e;\n                  console.log(\'      âš ï¸ Ù…Ø­Ø§ÙˆÙ„Ø© ÙØ´Ù„Øª: \' + e.message);\n        \n                  if (retry < config.maxRetries - 1) {\n                    await frameHandle.waitForTimeout(500);\n                  }\n                }\n              }\n        \n              if (clickSuccess) break;\n            } catch (e) {\n              lastError = e;\n              console.log(\'âš ï¸ Ø®Ø·Ø£ Ù…Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯ \' + elementSelector + \': \' + e.message);\n              continue;\n            }\n          }\n        \n          if (!clickSuccess) {\n            throw new Error(\n              \'ÙØ´Ù„ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ± Ø¯Ø§Ø®Ù„ iframe Ø¨Ø¹Ø¯ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø©. \' +\n              \'Ø§Ù„Ø®Ø·Ø£: \' + (lastError?.message || \'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ\')\n            );\n          }\n        \n          console.log(\'ğŸ‰ Ø§ÙƒØªÙ…Ù„ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ± Ø¯Ø§Ø®Ù„ iframe Ø¨Ù†Ø¬Ø§Ø­!\');\n          return { success: true };\n        }\n        \n        // ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬\n        const result = await clickElementInCrossOriginIFrame(page);\n        if (!result?.success) {\n          throw new Error(\'ÙØ´Ù„ Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø¹Ù†ØµØ± Ø¯Ø§Ø®Ù„ iframe\');\n        }\n                break;\n      } catch (stepError) {\n        retries_step6--;\n        if (retries_step6 === 0) {\n          throw stepError;\n        }\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n\n    // Step 7: Ø§Ù„ØªÙ‚Ø§Ø· ØµÙˆØ±Ø©\n    {\n      // ğŸ“¸ Ø§Ù„ØªÙ‚Ø§Ø· Ù„Ù‚Ø·Ø© Ø´Ø§Ø´Ø©\n      const screenshotPath = \"screenshot-1767677960861-fullpage.png\";\n      console.log(\'ğŸ“¸ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙ‚Ø§Ø· Ù„Ù‚Ø·Ø© Ø§Ù„Ø´Ø§Ø´Ø© (Ø§Ù„ØµÙØ­Ø© ÙƒØ§Ù…Ù„Ø©)...\');\n      await currentPage.screenshot({ path: screenshotPath, fullPage: true });\n      console.log(\'âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù„Ù‚Ø·Ø© ÙÙŠ:\', screenshotPath);\n          }\n\n    // Step 8: Ø§Ù†ØªØ¸Ø§Ø±\n    let retries_step8 = 3;\n    while (retries_step8 > 0) {\n      try {\n        await currentPage.waitForTimeout(5000);\n                break;\n      } catch (stepError) {\n        retries_step8--;\n        if (retries_step8 === 0) {\n          throw stepError;\n        }\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n\n    // Step 9: ÙØªØ­ ØµÙØ­Ø©\n    let retries_step9 = 3;\n    while (retries_step9 > 0) {\n      try {\n        // ğŸŒ ÙØªØ­ ØµÙØ­Ø©\n        await page.goto(\"https://pornhub.com\");\n        currentPage = page;\n        console.log(\'ğŸŒ ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„ØµÙØ­Ø©: https://pornhub.com\');\n                break;\n      } catch (stepError) {\n        retries_step9--;\n        if (retries_step9 === 0) {\n          throw stepError;\n        }\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n\n    // Step 10: Ø§Ù†ØªØ¸Ø§Ø±\n    let retries_step10 = 3;\n    while (retries_step10 > 0) {\n      try {\n        await currentPage.waitForTimeout(5000);\n                break;\n      } catch (stepError) {\n        retries_step10--;\n        if (retries_step10 === 0) {\n          throw stepError;\n        }\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n\n    // Step 11: Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ ØµÙØ­Ø©\n    let retries_step11 = 3;\n    while (retries_step11 > 0) {\n      try {\n        // â†©ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©\n        if (pages[\"resc\"]) {\n          await pages[\"resc\"].bringToFront();\n          currentPage = pages[\"resc\"];\n          console.log(\'â†©ï¸ ØªÙ… Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„ØµÙØ­Ø©: resc\');\n        } else {\n          throw new Error(\'Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©: \' + \"resc\");\n        }\n                break;\n      } catch (stepError) {\n        retries_step11--;\n        if (retries_step11 === 0) {\n          throw stepError;\n        }\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n\n    // Step 12: Ø§Ù†ØªØ¸Ø§Ø±\n    let retries_step12 = 3;\n    while (retries_step12 > 0) {\n      try {\n        await currentPage.waitForTimeout(5000);\n                break;\n      } catch (stepError) {\n        retries_step12--;\n        if (retries_step12 === 0) {\n          throw stepError;\n        }\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n\n    console.log(\"âœ… Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ù…Ù‡Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"âŒ Ø®Ø·Ø£:\", error.message);\n    return { success: false, error: error.message };\n  }\n}\n\n// Ø¯Ø§Ù„Ø© ØªØ´ØºÙŠÙ„ ÙØ¹Ù„ÙŠØ© - ØªØ¹Ù…Ù„ Ù…Ø¨Ø§Ø´Ø±Ø©\n(async () => {\n  let browser = null;\n  try {\n    // âš ï¸ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ØªØµÙØ­ Ø¨ØªØ¹Ø·ÙŠÙ„ Ø£Ù…Ø§Ù† Ø§Ù„ÙˆÙŠØ¨ (Cross-Origin)\n    console.log(\'\\nğŸŒ ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø®Ø·ÙˆØ§Øª Cross-Origin:\');\n    console.log(\'   âœ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ØªØµÙØ­ Ø¨Ù€ --disable-web-security\');\n    console.log(\'   ğŸ“Œ Ø§Ù„Ù‡Ø¯Ù: ØªØ¬Ø§ÙˆØ² Ù‚ÙŠÙˆØ¯ CORS Ùˆ iframe Ù…Ø­Ù…ÙŠØ©\');\n    console.log(\'   âš ï¸  ØªØ­Ø°ÙŠØ±: Ù‡Ø°Ø§ Ø§Ù„ÙˆØ¶Ø¹ ØºÙŠØ± Ø¢Ù…Ù† Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙŠ Ø§Ù„Ø¥Ù†ØªØ§Ø¬\\n\');\n    browser = await chromium.launch({\n      headless: true,\n      args: [\n        \'--disable-web-security\',\n        \'--disable-features=IsolateOrigins,site-per-process\',\n        \'--disable-site-isolation-trials\',\n        \'--disable-blink-features=AutomationControlled\',\n        \'--disable-dev-shm-usage\',\n        \'--no-sandbox\',\n        \'--disable-setuid-sandbox\'\n      ]\n    });\n    const contextOptions = {};\n    // ØªÙØ¹ÙŠÙ„ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø³ÙŠØ§Ù‚\n    contextOptions.recordVideo = { dir: \'videos\' };\n    const context = await browser.newContext(contextOptions);\n    const page = await context.newPage();\n    let executionSuccess = false;\n    let executionError = null;\n\n    // ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ù‡Ù…Ø©\n    try {\n      const result = await runTask(page, context);\n      executionSuccess = result.success;\n      console.log(\'ğŸ“Š Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªÙ†ÙÙŠØ°:\', result.success ? \'âœ… Ù†Ø¬Ø­Øª\' : \'âŒ ÙØ´Ù„Øª\');\n    } catch (taskError) {\n      executionError = taskError;\n      console.error(\'âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ù‡Ù…Ø©:\', taskError.message);\n    }\n  } catch (error) {\n    console.error(\'âŒ Ø®Ø·Ø£ Ø­Ø±Ø¬ ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©:\', error.message);\n  } finally {\n    // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ - Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø³ÙŠØ§Ù‚ ÙˆØ§Ù„Ù…ØªØµÙØ­ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·\n    try {\n      if (context) {\n        console.log(\'ğŸ”’ Ø¬Ø§Ø±ÙŠ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø³ÙŠØ§Ù‚ ÙˆØ­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ (Ø¥Ù† ÙˆØ¬Ø¯)...\');\n        await context.close(); // ÙŠØ­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹\n        console.log(\'âœ… ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø³ÙŠØ§Ù‚\');\n      }\n    } catch (contextError) {\n      console.warn(\'âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø³ÙŠØ§Ù‚:\', contextError.message);\n    }\n    try {\n      if (browser) {\n        console.log(\'ğŸ”’ Ø¬Ø§Ø±ÙŠ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù…ØªØµÙØ­...\');\n        await browser.close();\n        console.log(\'âœ… ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù…ØªØµÙØ­\');\n      }\n    } catch (browserError) {\n      console.warn(\'âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù…ØªØµÙØ­:\', browserError.message);\n    }\n    // Ø§Ù„Ø®Ø±ÙˆØ¬ Ø¨ÙƒÙˆØ¯ Ø§Ù„Ù†Ø¬Ø§Ø­/Ø§Ù„ÙØ´Ù„ Ø§Ù„ØµØ­ÙŠØ­\n    process.exit(executionSuccess ? 0 : 1);\n  }\n})();\n",
  "targetUrl": "https://rescend.netlify.app/",
  "createdAt": "2026-01-06T04:17:14.745Z",
  "metadata": {
    "source": "advanced-builder",
    "stepsData": "[{\"id\":\"1767672940555\",\"type\":\"video\",\"params\":{\"codec\":\"vp9\",\"recordAudio\":false},\"fallbacks\":[],\"conditions\":[],\"errorHandling\":{\"ignoreErrors\":false,\"retryCount\":3}},{\"id\":\"1767672941646\",\"type\":\"navigate\",\"params\":{\"url\":\"https://rescend.netlify.app/\",\"pageLabel\":\"\",\"variableName\":\"resc\"},\"fallbacks\":[],\"conditions\":[],\"errorHandling\":{\"ignoreErrors\":false,\"retryCount\":3}},{\"id\":\"1767672943699\",\"type\":\"wait\",\"params\":{\"type\":\"time\",\"duration\":5000},\"fallbacks\":[],\"conditions\":[],\"errorHandling\":{\"ignoreErrors\":false,\"retryCount\":3}},{\"id\":\"1767673326416\",\"type\":\"scroll\",\"params\":{\"position\":\"end\",\"behavior\":\"finger\",\"scrollType\":\"finger\",\"humanize\":true,\"duration\":800,\"randomVariation\":24,\"microMoves\":true,\"pauseFrequency\":2000,\"pauseDuration\":200,\"gestureIntensity\":4,\"momentumFriction\":0.95,\"flickVelocity\":2.5},\"fallbacks\":[],\"conditions\":[],\"errorHandling\":{\"ignoreErrors\":false,\"retryCount\":3}},{\"id\":\"1767672996010\",\"type\":\"wait\",\"params\":{\"type\":\"time\",\"duration\":8950},\"fallbacks\":[],\"conditions\":[],\"errorHandling\":{\"ignoreErrors\":false,\"retryCount\":3}},{\"id\":\"1767673427655\",\"type\":\"click\",\"params\":{\"selector\":\"a[href*=\'cultivated-cell.com\']\",\"iframeSelector\":\"iframe.â–¶__iframe\"},\"fallbacks\":[],\"conditions\":[],\"errorHandling\":{\"ignoreErrors\":false,\"retryCount\":3},\"smartOptions\":{\"searchByText\":\"\",\"searchByAttributes\":{},\"waitForVisibility\":true,\"scrollIntoView\":true,\"handleDynamicElements\":false,\"maxWaitTime\":5000},\"iframeOptions\":{\"isCrossOrigin\":true,\"nestedIframes\":false}},{\"id\":\"1767673348948\",\"type\":\"screenshot\",\"params\":{\"fullPage\":true},\"fallbacks\":[],\"conditions\":[],\"errorHandling\":{\"ignoreErrors\":false,\"retryCount\":0}},{\"id\":\"1767673360770\",\"type\":\"wait\",\"params\":{\"type\":\"time\",\"duration\":5000},\"fallbacks\":[],\"conditions\":[],\"errorHandling\":{\"ignoreErrors\":false,\"retryCount\":3}},{\"id\":\"1767672970851\",\"type\":\"navigate\",\"params\":{\"url\":\"https://pornhub.com\",\"pageLabel\":\"\",\"variableName\":\"\"},\"fallbacks\":[],\"conditions\":[],\"errorHandling\":{\"ignoreErrors\":false,\"retryCount\":3}},{\"id\":\"1767673017017\",\"type\":\"wait\",\"params\":{\"type\":\"time\",\"duration\":5000},\"fallbacks\":[],\"conditions\":[],\"errorHandling\":{\"ignoreErrors\":false,\"retryCount\":3}},{\"id\":\"1767673002720\",\"type\":\"goToPage\",\"params\":{\"variableName\":\"resc\"},\"fallbacks\":[],\"conditions\":[],\"errorHandling\":{\"ignoreErrors\":false,\"retryCount\":3}},{\"id\":\"1767673534222\",\"type\":\"wait\",\"params\":{\"type\":\"time\",\"duration\":5000},\"fallbacks\":[],\"conditions\":[],\"errorHandling\":{\"ignoreErrors\":false,\"retryCount\":3}}]"
  },
  "lastRun": "2026-01-06T05:10:06.829Z"
};

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø®Ø·ÙˆØ§Øª ÙÙŠØ¯ÙŠÙˆ
function hasVideoStep(script) {
  return script && (
    script.includes(\'recordVideo\') ||
    script.includes("\'video\'") ||
    script.includes(\'"video"\') ||
    script.includes(\'ğŸ¥\')
  );
}

async function runTask() {
  console.log(\'ğŸš€ Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ù‡Ù…Ø©: \' + TASK.name);
  console.log(\'ğŸ“ Ø§Ù„ÙˆØµÙ: \' + TASK.description);
  console.log(\'ğŸ¯ Ø§Ù„Ù‡Ø¯Ù: \' + TASK.targetUrl);

  const startTime = Date.now();
  let taskResult = null;
  let executionStatus = \'unknown\';
  let executionError = null;
  let screenshotPath = null;
  const artifacts = [];

  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø§Ø¬Ø© Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
  const needsVideoRecording = hasVideoStep(TASK.script);
  if (needsVideoRecording) {
    console.log(\'ğŸ¥ ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø®Ø·ÙˆØ© ÙÙŠØ¯ÙŠÙˆ - Ø³ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¬Ù„Ø³Ø©\');
  }

  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø§Ø¬Ø© Ù„ØªØ¹Ø·ÙŠÙ„ Ø£Ù…Ø§Ù† Ø§Ù„ÙˆÙŠØ¨ (Cross-Origin)
  
  const needsDisableSecurity = true;
  if (needsDisableSecurity) {
    console.log(\'ğŸŒ ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø®Ø·ÙˆØ§Øª Cross-Origin - Ø³ÙŠØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ØªØµÙØ­ Ø¨Ù€ --disable-web-security\');
  }
  

  // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù‚Ø¨Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ØªØµÙØ­
  await fs.mkdir(\'screenshots\', { recursive: true });
  await fs.mkdir(\'videos\', { recursive: true });

  // Ø¥Ù†Ø´Ø§Ø¡ Ù…ØªØµÙØ­ Stealth Ù…Ø¹ Ø¯Ø¹Ù… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙˆØ§Ù„Ù€ Cross-Origin Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
  const { browser, context, page } = await createStealthBrowser({
    recordVideo: needsVideoRecording,
    disableWebSecurity: needsDisableSecurity
  });

  try {
    // Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„ØµÙØ­Ø©
    console.log(\'ğŸŒ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰:\', TASK.targetUrl);
    await page.goto(TASK.targetUrl, {
      waitUntil: \'domcontentloaded\',
      timeout: 30000
    });

    console.log(\'âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø© Ø¨Ù†Ø¬Ø§Ø­\');

    // ØªÙ†ÙÙŠØ° Ø§Ù„Ø³ÙƒØ±ÙŠØ¨Øª
    
    // ØªÙ†ÙÙŠØ° Ø§Ù„Ø³ÙƒØ±ÙŠØ¨Øª Ø§Ù„Ù…Ø®ØµØµ (Ù…Ù† Ø§Ù„Ù…Ù†Ø´Ø¦ Ø§Ù„Ù…Ø±Ø¦ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…)
    console.log(\'âš™ï¸ Ø¨Ø¯Ø¡ ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ù‡Ù…Ø©...\');

    let stepResults = [];
    // ØªÙ‡ÙŠØ¦Ø© ÙƒØ§Ø¦Ù† Ø§Ù„ØµÙØ­Ø§Øª Ù„ØªØ®Ø²ÙŠÙ† Ù…Ø±Ø§Ø¬Ø¹ Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©
    const pages = {};
    pages[\'main\'] = page; // ØªØ®Ø²ÙŠÙ† Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©

    try {
      // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙˆÙ…ØªØºÙŠØ±Ø§Øª Ø§Ù„ØªØªØ¨Ø¹
  let currentPage = page;
  const pages = {};
  pages[\'main\'] = page;
  
  try {
    // Step 1: ØªØ³Ø¬ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆ
    let retries_step1 = 3;
    while (retries_step1 > 0) {
      try {
        // ğŸ¥ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ - ØªÙ… ØªÙØ¹ÙŠÙ„Ù‡ Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø³ÙŠØ§Ù‚
        console.log(\'ğŸ¥ Ø®Ø·ÙˆØ© Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù†Ø´Ø·\');
        console.log(\'   â„¹ï¸  Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙŠØ´Ù…Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙØ­Ø§Øª ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø³ÙŠØ§Ù‚\');
        console.log(\'   ğŸ“ Ø­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: videos/\');
        console.log(\'   âœ… Ø³ÙŠØªÙ… Ø­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ù†Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø³ÙŠØ§Ù‚ (Ù†Ø¬Ø§Ø­ Ø£Ùˆ ÙØ´Ù„)\');
                break;
      } catch (stepError) {
        retries_step1--;
        if (retries_step1 === 0) {
          throw stepError;
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Step 2: ÙØªØ­ ØµÙØ­Ø©
    let retries_step2 = 3;
    while (retries_step2 > 0) {
      try {
        // ğŸŒ ÙØªØ­ ØµÙØ­Ø© Ø¬Ø¯ÙŠØ¯Ø©: https://rescend.netlify.app/
        const resc = await context.newPage();
        await resc.goto("https://rescend.netlify.app/");
        pages["resc"] = resc;
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„Ø¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        currentPage = resc;
        console.log(\'ğŸŒ ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ ØµÙØ­Ø© Ø¬Ø¯ÙŠØ¯Ø©: https://rescend.netlify.app/\');
                break;
      } catch (stepError) {
        retries_step2--;
        if (retries_step2 === 0) {
          throw stepError;
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Step 3: Ø§Ù†ØªØ¸Ø§Ø±
    let retries_step3 = 3;
    while (retries_step3 > 0) {
      try {
        await currentPage.waitForTimeout(5000);
                break;
      } catch (stepError) {
        retries_step3--;
        if (retries_step3 === 0) {
          throw stepError;
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Step 4: ØªÙ…Ø±ÙŠØ± Ø§Ù„ØµÙØ­Ø©
    let retries_step4 = 3;
    while (retries_step4 > 0) {
      try {
        // ğŸ“œ ØªÙ…Ø±ÙŠØ± Ø·Ø¨ÙŠØ¹ÙŠ ÙˆØ¨Ø´Ø±ÙŠ
        const scrollTarget = await currentPage.evaluate(() => document.body.scrollHeight - window.innerHeight);
        
        // ØªÙ…Ø±ÙŠØ± Ø·Ø¨ÙŠØ¹ÙŠ Ø¨Ø­Ø±ÙƒØ© Ø§Ù„Ø¥ØµØ¨Ø¹ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø©
        await page.evaluate(async ({ from, to, fingerTouches, randomVariation }) => {
          return new Promise((resolve) => {
            const distance = to - from;
            const direction = distance > 0 ? 1 : -1;
            let currentPos = from;
            let touchIndex = 0;
            let velocity = 0;
        
            const simulateFingerGesture = async () => {
              // Ø­Ø±ÙƒØ© Ø§Ù„Ø¥ØµØ¨Ø¹ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø© Ù…Ø¹ ØªØ¨Ø§ÙŠÙ† Ø¹Ø´ÙˆØ§Ø¦ÙŠ
              const touchStepSize = Math.abs(distance) / fingerTouches;
              const touchDuration = 900 / fingerTouches;
              const baseDelay = touchDuration / 4;
        
              while ((direction > 0 ? currentPos < to : currentPos > to)) {
                touchIndex++;
                const nextPos = Math.min(Math.max(currentPos + (touchStepSize * direction), from), to);
                const variation = 1 + ((Math.random() - 0.5) * randomVariation / 100);
                const stepDuration = touchDuration * variation;
        
                // Ù…Ø­Ø§ÙƒØ§Ø© Ø­Ø±ÙƒØ© Ø§Ù„Ø¥ØµØ¨Ø¹ Ù…Ø¹ ØªØ³Ø§Ø±Ø¹ Ø·Ø¨ÙŠØ¹ÙŠ
                await new Promise(resolve => {
                  const startTime = performance.now();
                  const startPos = currentPos;
        
                  const animateFinger = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / stepDuration, 1);
        
                    // ØªØ³Ø§Ø±Ø¹ Ø·Ø¨ÙŠØ¹ÙŠ Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¥ØµØ¨Ø¹
                    const easeProgress = progress < 0.5
                      ? 2 * progress * progress
                      : -1 + (4 - 2 * progress) * progress;
        
                    currentPos = startPos + (nextPos - startPos) * easeProgress;
                    window.scrollTo(0, currentPos);
        
                    if (progress < 1) {
                      requestAnimationFrame(animateFinger);
                    } else {
                      window.scrollTo(0, nextPos);
                      velocity = (nextPos - startPos) / stepDuration;
                      resolve();
                    }
                  };
        
                  requestAnimationFrame(animateFinger);
                });
        
                // ØªÙˆÙ‚Ù Ø¹Ø´ÙˆØ§Ø¦ÙŠ ØµØºÙŠØ± Ø¨ÙŠÙ† Ø§Ù„Ø­Ø±ÙƒØ§Øª (Ù…Ø­Ø§ÙƒØ§Ø© Ø­Ø±ÙƒØ© Ø§Ù„Ø¥ØµØ¨Ø¹ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ©)
                await new Promise(r => setTimeout(r, baseDelay * (0.5 + Math.random())));
              }
        
              // ØªÙˆÙ‚Ù Ù†Ù‡Ø§Ø¦ÙŠ
              window.scrollTo(0, to);
              resolve();
            };
        
            simulateFingerGesture();
          });
        }, {
          from: 0,
          to: 999999,
          fingerTouches: 6,
          randomVariation: 20
        });
                break;
      } catch (stepError) {
        retries_step4--;
        if (retries_step4 === 0) {
          throw stepError;
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Step 5: Ø§Ù†ØªØ¸Ø§Ø±
    let retries_step5 = 3;
    while (retries_step5 > 0) {
      try {
        await currentPage.waitForTimeout(8950);
                break;
      } catch (stepError) {
        retries_step5--;
        if (retries_step5 === 0) {
          throw stepError;
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Step 6: Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø¹Ù†ØµØ±
    let retries_step6 = 3;
    while (retries_step6 > 0) {
      try {
        
        // ğŸ‘† Ø®Ø·ÙˆØ© Ù†Ù‚Ø± Ø°ÙƒÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ±
        console.log(\'ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¹Ù†ØµØ± Ø¨Ù€ 1 Ù…Ø­Ø¯Ø¯(Ø§Øª)...\');
        
        // ğŸ”— Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø·ÙˆØ© ØªØ³ØªÙ‡Ø¯Ù Ø¹Ù†ØµØ±Ø§Ù‹ Ø¯Ø§Ø®Ù„ iframe (Ù…Ø¹ Ø¯Ø¹Ù… cross-origin CORS)
        // âš ï¸ ØªØ­Ø°ÙŠØ±: Ù‡Ø°Ø§ iframe Ù…Ù† Ø¯ÙˆÙ…ÙŠÙ† Ø®Ø§Ø±Ø¬ÙŠ (Cross-Origin)
        // ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ --disable-web-security Ø¹Ù†Ø¯ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ØªØµÙØ­
        
        // Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø­Ø¯Ø¯Ø§Øª iframe Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©
        let iframeElement = null;
        const iframeSelectorsToTry = ["iframe.â–¶__iframe"];
        
        for (const ifSel of iframeSelectorsToTry) {
          try {
            iframeElement = await page.locator(ifSel).first();
            const exists = await iframeElement.count().catch(() => 0) > 0;
            if (exists) {
              console.log(\'âœ… ÙˆØ¬Ø¯Ù†Ø§ iframe Ø¨Ù€ selector:\', ifSel);
              break;
            }
          } catch (e) {
            console.log(\'âš ï¸ ÙØ´Ù„ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† iframe Ø¨Ù€:\', ifSel);
          }
        }
        
        if (!iframeElement) throw new Error(\'âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ iframe\');
        // ============================================
        // Ù…Ø¹Ø§Ù„Ø¬ Ù…ØªÙ‚Ø¯Ù… Ù„Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø¹Ù†Ø§ØµØ± Ø¯Ø§Ø®Ù„ iframe Ù…Ø­Ù…ÙŠØ© CORS
        // Advanced handler for clicking elements inside cross-origin iframes
        // ============================================
        
        async function clickElementInCrossOriginIFrame(page) {
          const iframeSelector = "iframe.â–¶__iframe";
          const elementSelectors = ["a[href*=\'cultivated-cell.com\']"];
          const config = {
            timeout: 5000,
            maxRetries: 3,
            handleHiddenElements: true
          };
        
          console.log(\'ğŸ” Ù…Ø¹Ø§Ù„Ø¬ Ù…ØªÙ‚Ø¯Ù… Ù„Ù„Ù€ iframe Ù…Ø­Ù…ÙŠØ© CORS\');
        
          let iframeElement = null;
          let frameHandle = null;
          let isCrossOrigin = false;
        
          // Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† iframe ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†ÙˆØ¹Ù‡
          console.log(\'ğŸ” Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† iframe ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£ØµÙ„Ù‡...\');
        
          try {
            const iframe = await page.locator(iframeSelector).first();
            const exists = await iframe.count().catch(() => 0) > 0;
        
            if (!exists) {
              throw new Error(\'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ iframe: \' + iframeSelector);
            }
        
            iframeElement = iframe;
            console.log(\'âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ iframe\');
        
            // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ÙƒØ´Ù Ø¹Ù† Ù†ÙˆØ¹ iframe (same-origin Ø£Ùˆ cross-origin)
            console.log(\'ğŸ” ÙØ­Øµ Ù†ÙˆØ¹ iframe...\');
        
            // Ù…Ø­Ø§ÙˆÙ„Ø© contentFrame() Ø£ÙˆÙ„Ø§Ù‹ (Ù„Ù„Ù€ same-origin)
            try {
              frameHandle = await iframeElement.contentFrame();
              if (frameHandle) {
                isCrossOrigin = false;
                console.log(\'âœ… iframe Ù…Ù† Ù†ÙØ³ Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ† (same-origin) - Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… contentFrame()\');
              }
            } catch (e) {
              // contentFrame() ÙØ´Ù„ - ÙŠØ¹Ù†ÙŠ Ù‡Ø°Ø§ cross-origin iframe
              isCrossOrigin = true;
              console.log(\'âš ï¸ ØªÙ… Ø§ÙƒØªØ´Ø§Ù iframe Ù…Ù† Ø¯ÙˆÙ…ÙŠÙ† Ø®Ø§Ø±Ø¬ÙŠ (Cross-Origin)\');
              console.log(\'   Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… frameLocator() Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† contentFrame()\');
            }
          } catch (e) {
            throw new Error(\'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† iframe: \' + e.message);
          }
        
          // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª cross-originØŒ Ø§Ø³ØªØ®Ø¯Ù… frameLocator() Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† contentFrame()
          if (isCrossOrigin) {
            console.log(\'\nğŸ”— Ù…Ø¹Ø§Ù„Ø¬Ø© Cross-Origin iframe Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… frameLocator()...\');
        
            // Ø§Ø³ØªØ®Ø¯Ø§Ù… frameLocator() Ø§Ù„Ø°ÙŠ ÙŠØ¹Ù…Ù„ Ù…Ø¹ Cross-Origin iframes
            console.log(\'ğŸ“ Ø§Ø³ØªØ®Ø¯Ø§Ù… frameLocator() Ù„Ù„Ø¨Ø­Ø« Ø¯Ø§Ø®Ù„ iframe Ù…Ù† Ø¯ÙˆÙ…ÙŠÙ† Ø®Ø§Ø±Ø¬ÙŠ...\');
        
            let clickSuccess = false;
            let lastError = null;
        
            for (const elementSelector of elementSelectors) {
              try {
                console.log(\'   Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯: \' + elementSelector);
        
                // Ø§Ø³ØªØ®Ø¯Ø§Ù… frameLocator Ù…Ø¹ elementSelector
                const frameLocatorElement = page.frameLocator(iframeSelector).locator(elementSelector).first();
                const exists = await frameLocatorElement.count().catch(() => 0) > 0;
        
                if (!exists) {
                  console.log(\'   âš ï¸ Ø§Ù„Ù…Ø­Ø¯Ø¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯: \' + elementSelector);
                  continue;
                }
        
                console.log(\'   âœ… ÙˆØ¬Ø¯Ù†Ø§ Ø§Ù„Ø¹Ù†ØµØ± Ø¯Ø§Ø®Ù„ iframe\');
        
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±Ø¤ÙŠØ© ÙˆØ§Ù„Ù†Ù‚Ø±
                if (config.handleHiddenElements) {
                  try {
                    const isVisible = await frameLocatorElement.isVisible({ timeout: 1000 }).catch(() => false);
        
                    if (!isVisible) {
                      console.log(\'   ğŸ”“ Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø®ÙÙŠ...\');
        
                      await page.frameLocator(iframeSelector).evaluate((sel) => {
                        const el = document.querySelector(sel);
                        if (el) {
                          el.style.display = \'\';
                          el.style.visibility = \'\';
                          el.style.opacity = \'1\';
                          el.style.zIndex = \'99999\';
                          el.removeAttribute(\'hidden\');
                        }
                      }, elementSelector);
        
                      console.log(\'   âœ… ØªÙ… Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¹Ù†ØµØ±\');
                    }
                  } catch (e) {
                    console.log(\'   âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¹Ù†ØµØ±: \' + e.message);
                  }
                }
        
                // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ø¹Ù†ØµØ± Ø¥Ù„Ù‰ Ø¹Ø±Ø¶ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
                try {
                  await frameLocatorElement.scrollIntoViewIfNeeded();
                  console.log(\'   ğŸ“œ ØªÙ… Ø§Ù„ØªÙ…Ø±ÙŠØ± Ø¥Ù„Ù‰ Ø¹Ø±Ø¶ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§\');
                } catch (e) {
                  console.log(\'   âš ï¸ ÙØ´Ù„ Ø§Ù„ØªÙ…Ø±ÙŠØ±: \' + e.message);
                }
        
                // ØªÙ†ÙÙŠØ° Ø§Ù„Ù†Ù‚Ø±Ø©
                console.log(\'   ğŸ–±ï¸ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ±...\');
                try {
                  await frameLocatorElement.click({ timeout: 5000 });
                  console.log(\'   âœ… ØªÙ… Ø§Ù„Ù†Ù‚Ø± Ø¨Ù†Ø¬Ø§Ø­\');
                  clickSuccess = true;
                  break;
                } catch (clickError) {
                  console.log(\'   âš ï¸ ÙØ´Ù„ Ø§Ù„Ù†Ù‚Ø± Ø§Ù„Ø¹Ø§Ø¯ÙŠØŒ Ø¬Ø§Ø±ÙŠ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ù†Ù‚Ø± Ø§Ù„Ø¬Ø¨Ø±ÙŠ...\');
                  try {
                    await frameLocatorElement.click({ force: true });
                    console.log(\'   âœ… ØªÙ… Ø§Ù„Ù†Ù‚Ø± Ø§Ù„Ø¬Ø¨Ø±ÙŠ Ø¨Ù†Ø¬Ø§Ø­\');
                    clickSuccess = true;
                    break;
                  } catch (forceClickError) {
                    lastError = forceClickError;
                    console.log(\'   âŒ ÙØ´Ù„ Ø§Ù„Ù†Ù‚Ø± Ø§Ù„Ø¬Ø¨Ø±ÙŠ: \' + forceClickError.message);
                  }
                }
              } catch (e) {
                lastError = e;
                console.log(\'   âŒ Ø®Ø·Ø£: \' + e.message);
                continue;
              }
            }
        
            if (!clickSuccess) {
              throw new Error(
                \'ÙØ´Ù„ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ± Ø¯Ø§Ø®Ù„ Cross-Origin iframe. \n\' +
                \'Ø§Ù„Ø³Ø¨Ø¨ Ø§Ù„Ù…Ø­ØªÙ…Ù„: \' + (lastError?.message || \'Ø§Ù„Ø¹Ù†ØµØ± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ ØºÙŠØ± Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªÙØ§Ø¹Ù„\') + \'\n\' +
                \'ØªØ£ÙƒØ¯ Ù…Ù†: 1) Ø§Ù„Ù…Ø­Ø¯Ø¯ ØµØ­ÙŠØ­ 2) Ø§Ù„Ù…ØªØµÙØ­ ÙŠØ¹Ù…Ù„ Ø¨Ù€ --disable-web-security 3) Ø§Ù„Ø¹Ù†ØµØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ iframe\'
              );
            }
        
            return; // Ù†Ù‡Ø§ÙŠØ© Ù…Ø¹Ø§Ù„Ø¬Ø© cross-origin
          }
        
          // Ø¥Ø°Ø§ Ù†Ø¬Ø­Ù†Ø§ ÙÙŠ Ø§Ù„Ø¯Ø®ÙˆÙ„ (same-origin)
          console.log(\'\nğŸ” Ø§Ù„Ø®Ø·ÙˆØ© 2: Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¹Ù†ØµØ± Ø¯Ø§Ø®Ù„ iframe...\');
        
          let clickSuccess = false;
          let lastError = null;
        
          for (const elementSelector of elementSelectors) {
            try {
              console.log(\'   Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯: \' + elementSelector);
        
              const element = await frameHandle.locator(elementSelector).first();
              const exists = await element.count().catch(() => 0) > 0;
        
              if (!exists) {
                console.log(\'   âš ï¸ Ø§Ù„Ù…Ø­Ø¯Ø¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯: \' + elementSelector);
                continue;
              }
        
              console.log(\'   âœ… ÙˆØ¬Ø¯Ù†Ø§ Ø§Ù„Ø¹Ù†ØµØ±\');
        
              // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¹Ù†ØµØ± Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
              if (config.handleHiddenElements) {
                try {
                  const isVisible = await element.isVisible({ timeout: 1000 }).catch(() => false);
        
                  if (!isVisible) {
                    console.log(\'   ğŸ”“ Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø®ÙÙŠ...\');
        
                    await frameHandle.evaluate((sel) => {
                      const el = document.querySelector(sel);
                      if (el) {
                        el.style.display = \'\';
                        el.style.visibility = \'\';
                        el.style.opacity = \'1\';
                        el.style.zIndex = \'99999\';
                        el.removeAttribute(\'hidden\');
                      }
                    }, elementSelector);
        
                    await element.scrollIntoViewIfNeeded().catch(() => {});
                    await frameHandle.waitForTimeout(300);
                  }
                } catch (e) {
                  console.log(\'   âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¹Ù†ØµØ±: \' + e.message);
                }
              }
        
              // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ù†Ù‚Ø±
              for (let retry = 0; retry < config.maxRetries; retry++) {
                try {
                  console.log(\'      Ù…Ø­Ø§ÙˆÙ„Ø© Ù†Ù‚Ø± \' + (retry + 1) + \'/\' + config.maxRetries);
        
                  if (retry === 0) {
                    await element.click({ timeout: 1000 }).catch(() => {});
                  } else if (retry === 1) {
                    await element.click({ force: true, timeout: 1000 });
                  } else {
                    await frameHandle.evaluate((sel) => {
                      const el = document.querySelector(sel);
                      if (el) el.click();
                    }, elementSelector);
                  }
        
                  console.log(\'      âœ… Ù†Ù‚Ø± Ù†Ø§Ø¬Ø­!\');
                  clickSuccess = true;
                  break;
                } catch (e) {
                  lastError = e;
                  console.log(\'      âš ï¸ Ù…Ø­Ø§ÙˆÙ„Ø© ÙØ´Ù„Øª: \' + e.message);
        
                  if (retry < config.maxRetries - 1) {
                    await frameHandle.waitForTimeout(500);
                  }
                }
              }
        
              if (clickSuccess) break;
            } catch (e) {
              lastError = e;
              console.log(\'âš ï¸ Ø®Ø·Ø£ Ù…Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯ \' + elementSelector + \': \' + e.message);
              continue;
            }
          }
        
          if (!clickSuccess) {
            throw new Error(
              \'ÙØ´Ù„ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ± Ø¯Ø§Ø®Ù„ iframe Ø¨Ø¹Ø¯ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø©. \' +
              \'Ø§Ù„Ø®Ø·Ø£: \' + (lastError?.message || \'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ\')
            );
          }
        
          console.log(\'ğŸ‰ Ø§ÙƒØªÙ…Ù„ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ± Ø¯Ø§Ø®Ù„ iframe Ø¨Ù†Ø¬Ø§Ø­!\');
          return { success: true };
        }
        
        // ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬
        const result = await clickElementInCrossOriginIFrame(page);
        if (!result?.success) {
          throw new Error(\'ÙØ´Ù„ Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø¹Ù†ØµØ± Ø¯Ø§Ø®Ù„ iframe\');
        }
                break;
      } catch (stepError) {
        retries_step6--;
        if (retries_step6 === 0) {
          throw stepError;
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Step 7: Ø§Ù„ØªÙ‚Ø§Ø· ØµÙˆØ±Ø©
    {
      // ğŸ“¸ Ø§Ù„ØªÙ‚Ø§Ø· Ù„Ù‚Ø·Ø© Ø´Ø§Ø´Ø©
      const screenshotPath = "screenshot-1767677960861-fullpage.png";
      console.log(\'ğŸ“¸ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙ‚Ø§Ø· Ù„Ù‚Ø·Ø© Ø§Ù„Ø´Ø§Ø´Ø© (Ø§Ù„ØµÙØ­Ø© ÙƒØ§Ù…Ù„Ø©)...\');
      await currentPage.screenshot({ path: screenshotPath, fullPage: true });
      console.log(\'âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù„Ù‚Ø·Ø© ÙÙŠ:\', screenshotPath);
          }

    // Step 8: Ø§Ù†ØªØ¸Ø§Ø±
    let retries_step8 = 3;
    while (retries_step8 > 0) {
      try {
        await currentPage.waitForTimeout(5000);
                break;
      } catch (stepError) {
        retries_step8--;
        if (retries_step8 === 0) {
          throw stepError;
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Step 9: ÙØªØ­ ØµÙØ­Ø©
    let retries_step9 = 3;
    while (retries_step9 > 0) {
      try {
        // ğŸŒ ÙØªØ­ ØµÙØ­Ø©
        await page.goto("https://pornhub.com");
        currentPage = page;
        console.log(\'ğŸŒ ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„ØµÙØ­Ø©: https://pornhub.com\');
                break;
      } catch (stepError) {
        retries_step9--;
        if (retries_step9 === 0) {
          throw stepError;
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Step 10: Ø§Ù†ØªØ¸Ø§Ø±
    let retries_step10 = 3;
    while (retries_step10 > 0) {
      try {
        await currentPage.waitForTimeout(5000);
                break;
      } catch (stepError) {
        retries_step10--;
        if (retries_step10 === 0) {
          throw stepError;
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Step 11: Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ ØµÙØ­Ø©
    let retries_step11 = 3;
    while (retries_step11 > 0) {
      try {
        // â†©ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
        if (pages["resc"]) {
          await pages["resc"].bringToFront();
          currentPage = pages["resc"];
          console.log(\'â†©ï¸ ØªÙ… Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„ØµÙØ­Ø©: resc\');
        } else {
          throw new Error(\'Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©: \' + "resc");
        }
                break;
      } catch (stepError) {
        retries_step11--;
        if (retries_step11 === 0) {
          throw stepError;
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Step 12: Ø§Ù†ØªØ¸Ø§Ø±
    let retries_step12 = 3;
    while (retries_step12 > 0) {
      try {
        await currentPage.waitForTimeout(5000);
                break;
      } catch (stepError) {
        retries_step12--;
        if (retries_step12 === 0) {
          throw stepError;
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    console.log("âœ… Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ù…Ù‡Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­");
    return { success: true };
  } catch (error) {
    console.error("âŒ Ø®Ø·Ø£:", error.message);
    return { success: false, error: error.message };
  }
    } catch (stepError) {
      console.error(\'âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ†ÙÙŠØ° Ø§Ù„Ø®Ø·ÙˆØ§Øª:\', stepError.message);
      throw stepError;
    }

    taskResult = {
      stepsExecuted: stepResults.length,
      success: true,
      results: stepResults
    };

    console.log(\'âœ… ØªÙ… ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø¨Ù†Ø¬Ø§Ø­\');
    console.log(\'ğŸ“Š Ù…Ù„Ø®Øµ Ø§Ù„Ù†ØªØ§Ø¦Ø¬:\', JSON.stringify(taskResult, null, 2));

    // Ø§Ù„ØªÙ‚Ø§Ø· ØµÙˆØ±Ø©
    console.log(\'ğŸ“¸ Ø§Ù„ØªÙ‚Ø§Ø· ØµÙˆØ±Ø© Ù„Ù„ØµÙØ­Ø©...\');
    screenshotPath = path.join(\'screenshots\', TASK.id + \'-\' + Date.now() + \'.png\');
    await page.screenshot({
      path: screenshotPath,
      fullPage: true
    });
    console.log(\'âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„ØµÙˆØ±Ø©:\', screenshotPath);
    artifacts.push(screenshotPath);

    executionStatus = \'success\';
    console.log(\'âœ… Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ù…Ù‡Ù…Ø© ÙÙŠ \' + ((Date.now() - startTime) / 1000).toFixed(2) + \' Ø«Ø§Ù†ÙŠØ©\');

  } catch (error) {
    console.error(\'âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ù‡Ù…Ø©:\', error.message);
    console.error(\'Stack trace:\', error.stack);

    executionStatus = \'failed\';
    executionError = error;

    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªÙ‚Ø§Ø· ØµÙˆØ±Ø© Ù„Ù„Ø®Ø·Ø£ - Ø¯Ø§Ø¦Ù…Ø§Ù‹
    try {
      const errorScreenshot = path.join(\'screenshots\', TASK.id + \'-error-\' + Date.now() + \'.png\');
      await page.screenshot({ path: errorScreenshot }).catch(() => {});
      console.log(\'ğŸ“¸ ØªÙ… Ø­ÙØ¸ ØµÙˆØ±Ø© Ø§Ù„Ø®Ø·Ø£:\', errorScreenshot);
      artifacts.push(errorScreenshot);
    } catch (e) {
      // ØªØ¬Ø§Ù‡Ù„ Ø£Ø®Ø·Ø§Ø¡ Ø­ÙØ¸ Ø§Ù„ØµÙˆØ±Ø©
    }

  } finally {
    try {
      // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± ØµØºÙŠØ± Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
      if (needsVideoRecording) {
        console.log(\'â³ Ø¬Ø§Ø±ÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ...\');
        await new Promise(resolve => setTimeout(resolve, 1000));
      }

      await browser.close();
      console.log(\'ğŸ”’ ØªÙ… Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù…ØªØµÙØ­\');

      // Ø¬Ù…Ø¹ Ù…Ù„ÙØ§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
      if (needsVideoRecording) {
        try {
          const videosDir = \'videos\';
          const videos = await fs.readdir(videosDir).catch(() => []);
          if (videos.length > 0) {
            console.log(`âœ… ØªÙ… Ø­ÙØ¸ ${videos.length} Ù…Ù„Ù ÙÙŠØ¯ÙŠÙˆ ÙÙŠ Ù…Ø¬Ù„Ø¯ ${videosDir}/`);
            videos.forEach(video => {
              const videoPath = path.join(videosDir, video);
              artifacts.push(videoPath);
              console.log(`   ğŸ“¹ ${videoPath}`);
            });
          } else {
            console.warn(\'âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù„ÙØ§Øª ÙÙŠØ¯ÙŠÙˆ Ø¹Ù„Ù‰ Ø§Ù„Ø±ØºÙ… Ù…Ù† ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„\');
          }
        } catch (e) {
          console.warn(\'âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ù…Ø¬Ù„Ø¯ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ:\', e.message);
        }
      }

      // Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø· Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø§Ø°ÙŠØ§Øª
      const duration = (Date.now() - startTime) / 1000;
      const resultData = {
        taskId: TASK.id,
        taskName: TASK.name,
        status: executionStatus,
        duration,
        timestamp: new Date().toISOString(),
        artifacts: artifacts, // Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª (ØµÙˆØ± + ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª)
        data: taskResult // Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬Ø©
      };

      // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø®Ø·Ø£ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø®Ø·Ø£
      if (executionError) {
        resultData.error = executionError.message;
        resultData.stack = executionError.stack;
      }

      await saveResults(resultData);

      // Ø¥Ø¹Ø§Ø¯Ø© Ø±Ù…ÙŠ Ø§Ù„Ø®Ø·Ø£ ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªÙ†ÙÙŠØ° Ù‚Ø¯ ÙØ´Ù„
      if (executionError) {
        throw executionError;
      }

      console.log(\'ğŸ‰ Ø§Ù„Ù…Ù‡Ù…Ø© Ù†Ø¬Ø­Øª Ø¨Ø§Ù„ÙƒØ§Ù…Ù„!\');

    } catch (finallyError) {
      if (finallyError === executionError) {
        // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø®Ø·Ø£ Ø§Ù„Ø£ØµÙ„ÙŠ
        throw finallyError;
      }
      console.error(\'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù€ finally:\', finallyError);
      throw finallyError;
    }
  }
}

async function saveResults(data) {
  await fs.mkdir(\'results\', { recursive: true });
  const filename = TASK.id + \'-\' + Date.now() + \'.json\';
  const filepath = path.join(\'results\', filename);
  await fs.writeFile(filepath, JSON.stringify(data, null, 2));
  console.log(\'ğŸ’¾ ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬:\', filepath);
  
  // Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù„Ù„Ø³Ø¬Ù„Ø§Øª
  console.log(\'\nğŸ“Š Ù…Ù„Ø®Øµ Ø§Ù„Ù†ØªØ§Ø¦Ø¬:\');
  console.log(JSON.stringify(data, null, 2));
}

runTask().catch(error => {
  console.error(\'ğŸ’¥ ÙØ´Ù„Øª Ø§Ù„Ù…Ù‡Ù…Ø©:\', error);
  process.exit(1);
});
'
          };
          
          const RUN_COUNT = parseInt(process.env.RUN_COUNT || '1', 10) || 1;
          
          console.log('ğŸ”„ Ø³ÙŠØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ù‡Ù…Ø© ' + RUN_COUNT + ' Ù…Ø±Ø§Øª');
          
          async function runTask(runNumber) {
            console.log('');
            console.log('â•'.repeat(60));
            console.log('ğŸš€ ØªØ´ØºÙŠÙ„ Ø±Ù‚Ù… #' + runNumber + ' Ù…Ù† ' + RUN_COUNT);
            console.log('â•'.repeat(60));
            
            const browser = await chromium.launch({
              headless: true,
              args: [
                '--disable-blink-features=AutomationControlled',
                STEALTH_CONFIG.blockWebRTC ? '--disable-webrtc' : '',
                '--no-sandbox',
                '--disable-dev-shm-usage'
              ].filter(Boolean)
            });

            try {
              const context = await browser.newContext({
                userAgent: STEALTH_CONFIG.randomUserAgent 
                  ? 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' 
                  : undefined,
                viewport: STEALTH_CONFIG.randomViewport 
                  ? { width: 1920, height: 1080 } 
                  : undefined
              });

              if (STEALTH_CONFIG.hideWebdriver) {
                await context.addInitScript(() => {
                  Object.defineProperty(navigator, 'webdriver', {
                    get: () => undefined
                  });
                });
              }

              const page = await context.newPage();
              
              try {
                console.log('â³ Ø§Ù„Ø°Ù‡Ø§Ø¨ Ø¥Ù„Ù‰ Ø§Ù„Ù…ÙˆÙ‚Ø¹: ' + TASK_DATA.targetUrl);
                await page.goto(TASK_DATA.targetUrl || 'https://example.com', {
                  waitUntil: 'networkidle'
                });
                
                const runDir = 'results/run_' + runNumber;
                if (!fs.existsSync(runDir)) {
                  fs.mkdirSync(runDir, { recursive: true });
                }
                
                console.log('ğŸ“¸ Ø§Ù„ØªÙ‚Ø§Ø· Ù„Ù‚Ø·Ø© Ø´Ø§Ø´Ø©...');
                await page.screenshot({ 
                  path: runDir + '/screenshot.png', 
                  fullPage: true 
                });
                
                const results = {
                  runNumber: runNumber,
                  taskName: TASK_DATA.name,
                  taskType: TASK_DATA.type,
                  status: 'success',
                  timestamp: new Date().toISOString(),
                  url: page.url(),
                  title: await page.title()
                };
                
                fs.writeFileSync(
                  runDir + '/results.json', 
                  JSON.stringify(results, null, 2)
                );
                
                console.log('âœ… ØªØ´ØºÙŠÙ„ #' + runNumber + ' Ø§ÙƒØªÙ…Ù„ Ø¨Ù†Ø¬Ø§Ø­');
                await context.close();
                return true;
                
              } catch (error) {
                console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ´ØºÙŠÙ„ #' + runNumber + ':', error.message);
                const runDir = 'results/run_' + runNumber;
                if (!fs.existsSync(runDir)) {
                  fs.mkdirSync(runDir, { recursive: true });
                }
                fs.writeFileSync(runDir + '/error.log', error.stack);
                return false;
              } finally {
                await context.close();
              }
            } finally {
              await browser.close();
            }
          }
          
          async function runAll() {
            console.log('ğŸ“Š Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ø©:');
            console.log('   Ø§Ù„Ù…Ù‡Ù…Ø©: ' + TASK_DATA.name);
            console.log('   Ø§Ù„Ù†ÙˆØ¹: ' + TASK_DATA.type);
            console.log('   Ø§Ù„Ù…ÙˆÙ‚Ø¹: ' + TASK_DATA.targetUrl);
            console.log('');
            
            let successCount = 0;
            let failureCount = 0;
            
            for (let i = 1; i <= RUN_COUNT; i++) {
              try {
                const success = await runTask(i);
                if (success) {
                  successCount++;
                } else {
                  failureCount++;
                }
              } catch (err) {
                console.error('ÙØ´Ù„ Ø§Ù„ØªØ´ØºÙŠÙ„ #' + i, err);
                failureCount++;
              }
              
              if (i < RUN_COUNT) {
                console.log('');
                console.log('â³ Ø§Ù†ØªØ¸Ø§Ø± 3 Ø«ÙˆØ§Ù†Ù Ù‚Ø¨Ù„ Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ§Ù„ÙŠ...');
                await new Promise(r => setTimeout(r, 3000));
              }
            }
            
            console.log('');
            console.log('â•'.repeat(60));
            console.log('ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:');
            console.log('   Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªØ´ØºÙŠÙ„Ø§Øª: ' + RUN_COUNT);
            console.log('   Ù†Ø¬Ø­: âœ… ' + successCount);
            console.log('   ÙØ´Ù„: âŒ ' + failureCount);
            console.log('â•'.repeat(60));
            
            if (failureCount > 0) {
              process.exit(1);
            }
          }
          
          runAll().catch(err => {
            console.error('ÙØ´Ù„ Ø§Ù„ØªÙ†ÙÙŠØ°:', err);
            process.exit(1);
          });
          EOF
          
          node run_task.js
        env:
          RUN_COUNT: ${{ inputs.runCount }}
          STEALTH_LEVEL: advanced
      
      - name: Upload Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: task-results-${{ github.run_number }}
          path: results/
          retention-days: 7
      
      - name: Generate Summary
        if: always()
        run: |
          echo "## ğŸ“Š Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØªØ´ØºÙŠÙ„" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Ø§Ù„Ù…Ù‡Ù…Ø©:** Ø¬Ù†Ø§Ù† Ø§Ù„ØªØºÙ„ÙŠÙ‚" >> $GITHUB_STEP_SUMMARY
          echo "**Ø§Ù„Ù†ÙˆØ¹:** custom" >> $GITHUB_STEP_SUMMARY
          echo "**Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„ØªØ´ØºÙŠÙ„:** ${{ inputs.runCount || '1' }}" >> $GITHUB_STEP_SUMMARY
          if [ -d results ]; then
            echo "**Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª Ø§Ù„Ù…Ù†Ø´Ø£Ø©:**" >> $GITHUB_STEP_SUMMARY
            ls -la results/ | grep "run_" | awk '{print "- " $NF}' >> $GITHUB_STEP_SUMMARY
          fi
